### 算法DAY2 | 977.有序数组的平方 / 209.长度最小的子数组 / 59.螺旋矩阵II / 数组总结

### 977.有序数组的平方

[题目链接](https://leetcode.cn/problems/squares-of-a-sorted-array/)

- 标签：数组、双指针
- 难度：4.0

> 给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
>
> 示例：
>
> ```java
> 输入：nums = [-4,-1,0,3,10]
> 输出：[0,1,9,16,100]
> 解释：平方后，数组变为 [16,1,0,9,100]
> 排序后，数组变为 [0,1,9,16,100]
> 
> 输入：nums = [-7,-3,2,3,11]
> 输出：[4,9,9,49,121]
> ```

> **进阶：**
>
> - 请你设计时间复杂度为 `O(n)` 的算法解决本问题



数组本来是有序的，因为平方变得无序，究其原因在于绝对值越大，平方越大，因此很容易想到**从两边同时开始遍历nums数组，按照绝对值从大到小的顺序将平方结果填入新数组**。

只遍历一趟，时间复杂度O(n)。思路很简单，代码也很简单。

```java
public int[] sortedSquares(int[] nums) {
    // 左指针
    int i = 0;
    // 右指针
    int j = nums.length - 1;
    // 辅助指针，用于新数组的从后向前遍历
    int k = nums.length - 1;

    int[] res = new int[nums.length];

    while(i <= j){
        if(nums[i] * nums[i] >= nums[j] * nums[j]){
            res[k--] = nums[i] * nums[i];
            i++;
        }else{
            res[k--] = nums[j] * nums[j];
            j--;
        }
    }
    return res;
}
```



### 209.长度最小的子数组

[题目链接](https://leetcode.cn/problems/minimum-size-subarray-sum/)

- 标签：数组、滑动窗口
- 难度：5.0

> 给定一个含有 n 个正整数的数组和一个正整数 target 。
>
> 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
>
> 示例：
>
> ```java
> 输入：target = 7, nums = [2,3,1,2,4,3]
> 输出：2
> 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
> 
> 输入：target = 4, nums = [1,4,4]
> 输出：1
>     
> 输入：target = 11, nums = [1,1,1,1,1,1,1,1]
> 输出：0
> ```



为什么这道题会想到滑动窗口？**因为我们要确定区间长度，这就需要两个指针去夹。**因为我们要计算两个指针之间的元素总和，滑动窗口**通过一次遍历就能计算所有可能的区间**。

设起始位置指针为i，结束指针为j，则以j的遍历作为外层循环。每当j走一步，sum就要累加j指向的元素；当sum超过target时，i指针出动，向后遍历的同时从sum中减掉i指向的元素，直到sum再次小于target，**此时就能夹出一个最短区间(j-i+1)**。随着j的遍历，直到滑动窗口滑到最后，期间不断更新这个最短区间的长度即可。

![2-1](.\img\2-1.gif)

代码实际写起来，有几个小细节容易出错：

```java
public int minSubArrayLen(int target, int[] nums) {
    // 初始化两个指针
    int i = 0;
    int j = 0;
    // sum记录当前区间总和
    int sum = 0;
    // minLen记录当前最小区间长度
    int minLen = Integer.MAX_VALUE;

    // 滑动窗口的外层循环一定记得是用结束指针j
    for(j = 0; j < nums.length; j++){
        // 一点点累加，直到sum达到target
        sum += nums[j];
        // i指针不断向后移动，从sum中减掉nums[i]
        while(sum >= target){
            sum -= nums[i];
            // 直到sum小于target
            if(sum < target){
                // 取这个时候的区间长度，注意是(j-i+1)
                minLen = minLen > (j-i+1) ? (j-i+1) : minLen;
            }
            // 注意：无论sum是否小于target，i指针都需要向后移动
            i++;
        }
    }
    // 返回最终的最小区间长度，考虑健壮性
    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}
```



### 59.螺旋矩阵II

[题目链接](https://leetcode.cn/problems/spiral-matrix-ii/)

- 标签：数组、模拟

- 难度：6.0

> 给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。
>
> 示例：
>
> ![2-2](.\img\2-2.jpg)
>
> ```java
> 输入：n = 3
> 输出（如上图）：[[1,2,3],[8,9,4],[7,6,5]]
>     
> 输入：n = 1
> 输出：[[1]]
> ```



**此题很重要，纯考查代码能力**，也就是手动模拟的能力。这种题没什么算法思想，乍一看简单，实际上手有一定的难度，也是我一直很不擅长的类型。

此题中再次涉及循环不变量原理，对于边界条件的设计是此题的核心。话不多说，直接上代码感受。

```java
public int[][] generateMatrix(int n) {
    // 开始位置的横坐标（纵坐标也是）
    int start = 0;
    // 待填充的数
    int count = 1;
    // 每一趟的边上都要留出offset这么宽，其实和loop值一样
    int offset = 1;

    // 往这里填
    int[][] res = new int[n][n];
    // 两个循环指针
    int i = 0;
    int j = 0;
    // 当前圈数
    int loop = 0;

    // 一共要转n/2（向下取整）圈
    while(loop++ < n / 2){
        // 左上到右上，12
        for(j = start; j < n - offset; j++){
            res[start][j] = count++;
        }

        // 右上到右下，34
        for(i = start; i < n - offset; i++){
            res[i][j] = count++;
        }

        // 右下到左下，56
        for(; j > start; j--){
            res[i][j] = count++;
        }

        // 左下回到左上，78
        for(; i > start; i--){
            res[i][j] = count++;
        }

        // 改变起点，即从9开始
        start++;
        offset++;
    }

    // 注意：如果n是奇数，还要额外填中心元素，即填9
    if(n % 2 == 1){
        res[n/2][n/2] = count;
    }

    return res;
}
```



### 数组总结

数组看似简单，但除了简单模拟外，也有几种常见的解题策略。

![2-3](.\img\2-3.png)

1. 二分法

   - 再次强调，**只要看到数组有序，优先选择二分法**，降低时间复杂度！

   - 二分法简单且常用，注意循环条件，个人习惯采用左闭右闭。

2. 双指针

   - 双指针可以在O(n)时间复杂度下，**通过两个指针同时遍历，完成暴力解法两个循环才能完成的工作**。

   - 双指针常用于数组和链表的操作中，有时候是为了降低时间复杂度，有时候只是因为一个指针不够用。

   - 双指针**还可以降低空间复杂度**，比如 27.移除元素 这道题，快指针遍历过的元素就不需要了，慢指针就可以在后面慢慢地、在原地填充新元素。

3. 滑动窗口

   - 双指针的变体，通过控制窗口起始和结束位置的两个指针，来动态更新窗口大小。
   - **精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**

4. 复杂的模拟

   - 模拟都是有原则性的，循环的控制条件也不是瞎写的，**一定要找到每个循环都共有的规律**
   - 多练，代码能力不是凭空来的